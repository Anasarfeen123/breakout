Step-by-Step

    Setup Window

        Use pygame.display.set_mode(...)

        Define screen dimensions, FPS

    Create Paddle

        Paddle class with movement via arrow keys

        Clamp position to screen bounds

    Add Ball

        Ball class with velocity

        Bounces off walls and paddle

    Add Bricks

        Grid of colored rectangles

        Remove on collision

    Add Collision Logic

        Ball hits brick → remove brick, bounce

        Ball hits paddle → bounce depending on where it hits

Optional Stretch Features

    Score counter

    Multiple levels

    Power-ups (widen paddle, multi-ball)

    Game over + restart screen

    Sound effects

import pygame
import time
import random
import math

# Initialize Pygame
pygame.init()

# Game constants
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
FPS = 60
PADDLE_SPEED = 8
BALL_SPEED = 6
BRICK_ROWS = 6
BRICK_COLS = 12
BRICK_WIDTH = 80
BRICK_HEIGHT = 30
POWERUP_FALL_SPEED = 3

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
ORANGE = (255, 165, 0)
PURPLE = (128, 0, 128)
CYAN = (0, 255, 255)

class Paddle:
    def __init__(self, x, y):
        self.width = 120
        self.height = 15
        self.x = x - self.width // 2
        self.y = y
        self.speed = PADDLE_SPEED
        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
    
    def update(self, keys, screen_width):
        if keys[pygame.K_LEFT] and self.rect.left > 0:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] and self.rect.right < screen_width:
            self.rect.x += self.speed
    
    def draw(self, screen):
        pygame.draw.rect(screen, WHITE, self.rect)
        pygame.draw.rect(screen, BLUE, self.rect, 2)

class Ball:
    def __init__(self, x, y):
        self.radius = 8
        self.x = x
        self.y = y
        self.vel_x = 0
        self.vel_y = 0
        self.rect = pygame.Rect(x - self.radius, y - self.radius, 
                               self.radius * 2, self.radius * 2)
        self.on_paddle = True
        self.speed_multiplier = 1.0
    
    def launch(self):
        if self.on_paddle:
            angle = random.uniform(-math.pi/4, math.pi/4)  # Random angle between -45° and 45°
            self.vel_x = BALL_SPEED * math.sin(angle)
            self.vel_y = -BALL_SPEED * math.cos(angle)
            self.on_paddle = False
    
    def update(self, paddle, screen_width, screen_height):
        if self.on_paddle:
            self.x = paddle.rect.centerx
            self.y = paddle.rect.top - self.radius
            self.rect.center = (self.x, self.y)
            return
        
        # Apply speed multiplier for powerups
        current_vel_x = self.vel_x * self.speed_multiplier
        current_vel_y = self.vel_y * self.speed_multiplier
        
        self.x += current_vel_x
        self.y += current_vel_y
        self.rect.center = (self.x, self.y)
        
        # Wall collisions
        if self.rect.left <= 0 or self.rect.right >= screen_width:
            self.vel_x = -self.vel_x
            self.x = max(self.radius, min(screen_width - self.radius, self.x))
        
        if self.rect.top <= 0:
            self.vel_y = -self.vel_y
            self.y = self.radius
        
        # Paddle collision
        if (self.rect.colliderect(paddle.rect) and self.vel_y > 0 and 
            self.rect.bottom >= paddle.rect.top):
            
            # Calculate hit position relative to paddle center
            hit_pos = (self.rect.centerx - paddle.rect.centerx) / (paddle.rect.width / 2)
            hit_pos = max(-1, min(1, hit_pos))  # Clamp between -1 and 1
            
            # Calculate new angle based on hit position
            angle = hit_pos * math.pi / 3  # Max 60 degrees
            speed = math.sqrt(self.vel_x**2 + self.vel_y**2)
            
            self.vel_x = speed * math.sin(angle)
            self.vel_y = -abs(speed * math.cos(angle))  # Always up
            
            # Ensure ball is above paddle
            self.y = paddle.rect.top - self.radius
            self.rect.center = (self.x, self.y)
    
    def reset(self, paddle):
        self.on_paddle = True
        self.vel_x = 0
        self.vel_y = 0
        self.speed_multiplier = 1.0
    
    def draw(self, screen):
        pygame.draw.circle(screen, WHITE, (int(self.x), int(self.y)), self.radius)
        pygame.draw.circle(screen, YELLOW, (int(self.x), int(self.y)), self.radius, 2)

class Brick:
    def __init__(self, x, y, color, powerup=None):
        self.rect = pygame.Rect(x, y, BRICK_WIDTH, BRICK_HEIGHT)
        self.color = color
        self.active = True
        self.powerup = powerup
    
    def draw(self, screen):
        if self.active:
            pygame.draw.rect(screen, self.color, self.rect)
            pygame.draw.rect(screen, WHITE, self.rect, 2)
            
            # Draw powerup indicator
            if self.powerup:
                center = self.rect.center
                pygame.draw.circle(screen, WHITE, center, 5)
                font = pygame.font.Font(None, 20)
                text = font.render("P", True, BLACK)
                text_rect = text.get_rect(center=center)
                screen.blit(text, text_rect)

class Powerup:
    def __init__(self, x, y, powerup_type):
        self.x = x
        self.y = y
        self.width = 30
        self.height = 20
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.type = powerup_type
        self.fall_speed = POWERUP_FALL_SPEED
        
        # Powerup colors and labels
        self.colors = {
            "1+lf": RED,      # Extra Life
            "spdn": GREEN,    # Speed Down
            "wdpd": BLUE,     # Wide Paddle
            "mbll": PURPLE    # Multi Ball
        }
        
        self.labels = {
            "1+lf": "LIFE",
            "spdn": "SLOW",
            "wdpd": "WIDE",
            "mbll": "MULTI"
        }
    
    def update(self):
        self.y += self.fall_speed
        self.rect.y = self.y
    
    def draw(self, screen):
        color = self.colors.get(self.type, WHITE)
        pygame.draw.rect(screen, color, self.rect)
        pygame.draw.rect(screen, WHITE, self.rect, 2)
        
        font = pygame.font.Font(None, 16)
        label = self.labels.get(self.type, self.type)
        text = font.render(label, True, WHITE)
        text_rect = text.get_rect(center=self.rect.center)
        screen.blit(text, text_rect)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Enhanced Brick Breaker")
        self.clock = pygame.time.Clock()
        
        # Game state
        self.score = 0
        self.lives = 3
        self.level = 1
        self.running = True
        self.game_over = False
        self.paused = False
        
        # Game objects
        self.paddle = Paddle(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50)
        self.ball = Ball(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 70)
        self.bricks = []
        self.powerups = []
        
        # Active effects
        self.active_effects = {}
        
        # Fonts
        self.font_large = pygame.font.Font(None, 48)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 24)
        
        # Flash message system
        self.flash_message = ""
        self.flash_timer = 0
        
        self.create_bricks()
    
    def create_bricks(self):
        self.bricks = []
        colors = [RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE]
        
        start_x = (SCREEN_WIDTH - (BRICK_COLS * BRICK_WIDTH + (BRICK_COLS - 1) * 5)) // 2
        start_y = 100
        
        for row in range(BRICK_ROWS):
            for col in range(BRICK_COLS):
                x = start_x + col * (BRICK_WIDTH + 5)
                y = start_y + row * (BRICK_HEIGHT + 5)
                color = colors[row % len(colors)]
                
                # Random powerup chance (10%)
                powerup = None
                if random.random() < 0.1:
                    powerup = random.choice(["1+lf", "spdn", "wdpd"])
                
                brick = Brick(x, y, color, powerup)
                self.bricks.append(brick)
    
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                elif event.key == pygame.K_SPACE:
                    if self.ball.on_paddle:
                        self.ball.launch()
                    elif self.game_over:
                        self.restart_game()
                elif event.key == pygame.K_p:
                    self.paused = not self.paused
                elif event.key == pygame.K_r and self.game_over:
                    self.restart_game()
    
    def update(self):
        if self.paused or self.game_over:
            return
        
        keys = pygame.key.get_pressed()
        
        # Update game objects
        self.paddle.update(keys, SCREEN_WIDTH)
        self.ball.update(self.paddle, SCREEN_WIDTH, SCREEN_HEIGHT)
        
        # Check if ball fell off screen
        if self.ball.rect.top > SCREEN_HEIGHT:
            self.lives -= 1
            if self.lives <= 0:
                self.game_over = True
            else:
                self.ball.reset(self.paddle)
                self.flash_message = "Ball Lost!"
                self.flash_timer = time.time()
        
        # Ball-brick collisions
        for brick in self.bricks[:]:
            if brick.active and self.ball.rect.colliderect(brick.rect):
                self.handle_brick_collision(brick)
        
        # Update powerups
        for powerup in self.powerups[:]:
            powerup.update()
            
            # Check paddle collision
            if powerup.rect.colliderect(self.paddle.rect):
                self.activate_powerup(powerup.type)
                self.powerups.remove(powerup)
            
            # Remove if off screen
            elif powerup.y > SCREEN_HEIGHT:
                self.powerups.remove(powerup)
        
        # Update active effects
        self.update_effects()
        
        # Check win condition
        if not any(brick.active for brick in self.bricks):
            self.level += 1
            self.create_bricks()
            self.ball.reset(self.paddle)
            self.flash_message = f"Level {self.level}!"
            self.flash_timer = time.time()
    
    def handle_brick_collision(self, brick):
        # Determine collision side
        ball_center_x = self.ball.rect.centerx
        ball_center_y = self.ball.rect.centery
        brick_center_x = brick.rect.centerx
        brick_center_y = brick.rect.centery
        
        dx = ball_center_x - brick_center_x
        dy = ball_center_y - brick_center_y
        
        # Calculate overlaps
        overlap_x = (brick.rect.width + self.ball.rect.width) / 2 - abs(dx)
        overlap_y = (brick.rect.height + self.ball.rect.height) / 2 - abs(dy)
        
        # Bounce based on smallest overlap
        if overlap_x < overlap_y:
            self.ball.vel_x = -self.ball.vel_x
        else:
            self.ball.vel_y = -self.ball.vel_y
        
        # Deactivate brick and add score
        brick.active = False
        self.score += 10
        
        # Drop powerup if brick had one
        if brick.powerup:
            powerup = Powerup(brick.rect.centerx, brick.rect.centery, brick.powerup)
            self.powerups.append(powerup)
    
    def activate_powerup(self, powerup_type):
        self.flash_message = f"{powerup_type.upper()} Activated!"
        self.flash_timer = time.time()
        
        if powerup_type == "1+lf":
            self.lives += 1
        elif powerup_type == "spdn":
            self.active_effects["spdn"] = time.time()
            self.ball.speed_multiplier = 0.5
        elif powerup_type == "wdpd":
            self.active_effects["wdpd"] = time.time()
            self.paddle.width = 180
            # Update paddle rect
            center_x = self.paddle.rect.centerx
            self.paddle.rect = pygame.Rect(0, self.paddle.rect.y, self.paddle.width, self.paddle.height)
            self.paddle.rect.centerx = center_x
    
    def update_effects(self):
        effects_to_remove = []
        
        for effect, start_time in self.active_effects.items():
            if time.time() - start_time >= 10:  # 10 second duration
                effects_to_remove.append(effect)
                
                # Remove effect
                if effect == "spdn":
                    self.ball.speed_multiplier = 1.0
                elif effect == "wdpd":
                    center_x = self.paddle.rect.centerx
                    self.paddle.width = 120
                    self.paddle.rect = pygame.Rect(0, self.paddle.rect.y, self.paddle.width, self.paddle.height)
                    self.paddle.rect.centerx = center_x
        
        for effect in effects_to_remove:
            del self.active_effects[effect]
    
    def draw(self):
        self.screen.fill(BLACK)
        
        # Draw game objects
        self.paddle.draw(self.screen)
        self.ball.draw(self.screen)
        
        for brick in self.bricks:
            brick.draw(self.screen)
        
        for powerup in self.powerups:
            powerup.draw(self.screen)
        
        # Draw UI
        self.draw_ui()
        
        # Draw flash message
        if time.time() - self.flash_timer < 2:
            text = self.font_medium.render(self.flash_message, True, YELLOW)
            text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
            self.screen.blit(text, text_rect)
        
        # Draw game over screen
        if self.game_over:
            self.draw_game_over()
        
        # Draw pause screen
        if self.paused:
            text = self.font_large.render("PAUSED", True, WHITE)
            text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
            self.screen.blit(text, text_rect)
            
            instruction = self.font_small.render("Press P to resume", True, WHITE)
            instruction_rect = instruction.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))
            self.screen.blit(instruction, instruction_rect)
        
        pygame.display.flip()
    
    def draw_ui(self):
        # Score
        score_text = self.font_medium.render(f"Score: {self.score}", True, WHITE)
        self.screen.blit(score_text, (20, 20))
        
        # Lives
        lives_text = self.font_medium.render(f"Lives: {self.lives}", True, RED)
        self.screen.blit(lives_text, (SCREEN_WIDTH - 150, 20))
        
        # Level
        level_text = self.font_medium.render(f"Level: {self.level}", True, WHITE)
        self.screen.blit(level_text, (SCREEN_WIDTH // 2 - 50, 20))
        
        # Active effects
        y_offset = 60
        for effect, start_time in self.active_effects.items():
            remaining = max(0, int(10 - (time.time() - start_time)))
            effect_text = self.font_small.render(f"{effect.upper()}: {remaining}s", True, GREEN)
            self.screen.blit(effect_text, (SCREEN_WIDTH - 150, y_offset))
            y_offset += 30
        
        # Instructions
        if self.ball.on_paddle:
            instruction = self.font_small.render("Press SPACE to launch ball", True, WHITE)
            instruction_rect = instruction.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            self.screen.blit(instruction, instruction_rect)
    
    def draw_game_over(self):
        # Semi-transparent overlay
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        overlay.set_alpha(128)
        overlay.fill(BLACK)
        self.screen.blit(overlay, (0, 0))
        
        # Game over text
        game_over_text = self.font_large.render("GAME OVER", True, RED)
        game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        self.screen.blit(game_over_text, game_over_rect)
        
        # Final score
        final_score = self.font_medium.render(f"Final Score: {self.score}", True, WHITE)
        score_rect = final_score.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
        self.screen.blit(final_score, score_rect)
        
        # Restart instruction
        restart_text = self.font_small.render("Press SPACE or R to restart, ESC to quit", True, WHITE)
        restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))
        self.screen.blit(restart_text, restart_rect)
    
    def restart_game(self):
        self.score = 0
        self.lives = 3
        self.level = 1
        self.game_over = False
        self.active_effects.clear()
        self.powerups.clear()
        
        self.paddle = Paddle(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50)
        self.ball = Ball(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 70)
        self.create_bricks()
    
    def run(self):
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

# Run the game
if __name__ == "__main__":
    game = Game()
    game.run()